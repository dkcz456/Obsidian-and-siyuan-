# 完整的思源笔记 TypeScript + Svelte 插件开发 Google 编码规范指南

这是一份为思源笔记插件开发量身定制的超详细 Google 编码规范指南，涵盖了 TypeScript + Svelte 开发的方方面面，从基础配置到高级最佳实践，助你开发出企业级质量的插件。

## 🎯 核心原则与理念

### Google TypeScript Style Guide 核心准则

Google TypeScript Style Guide 基于以下四个核心原则：

**1. 避免已知问题模式**  
代码必须避免已知会导致问题的模式，特别是对语言新手而言。这包括避免 `@ts-ignore`、不使用 `var` 声明、不使用 `namespace` 等。

**2. 跨项目一致性**  
当存在两个表面上等效的选项时，应选择其中一个以避免无故分化演进，避免在代码审查中进行无意义的争论。例如：
- 命名的大写风格
- `x as T` 语法 vs `<T>x` 语法（后者被禁止）
- `Array<[number, number]>` vs `[number, number][]`

**3. 长期可维护性**  
代码通常比原作者工作的时间更长，TypeScript 团队必须保持所有 Google 代码在未来的正常工作。包括：
- 使用软件自动化代码更改，因此代码会被自动格式化
- 要求单一的编译器标志集
- 代码必须导入所使用的库（严格依赖）
- 要求用户编写测试

**4. 专注代码质量而非任意规则**  
代码审查者应专注于改进代码质量，而不是执行任意规则。如果可以将规则实现为自动检查，这通常是一个好兆头。

### 思源笔记插件开发特殊考虑

思源笔记插件开发有以下特殊要求：

1. **必须使用内核 API** - 如果插件需要直接读写数据目录下的文件，必须使用内核 API 实现，不得直接调用 fs 或其他 electron、nodejs API
2. **多设备同步兼容** - 考虑多设备同时运行时的配置冲突问题
3. **国际化支持** - 插件至少要支持英文和简体中文
4. **使用独立工作空间** - 开发时强烈建议使用独立的工作空间，避免对自己的笔记数据产生不良影响

## 🛠️ 完整的工具链配置

### 项目初始化

```bash
# 1. 克隆官方 Svelte 模板
git clone https://github.com/siyuan-note/plugin-sample-vite-svelte.git my-plugin
cd my-plugin

# 2. 安装 Google TypeScript Style 相关依赖
npm install --save-dev gts eslint-plugin-svelte prettier-plugin-svelte
npm install --save-dev @typescript-eslint/eslint-plugin @typescript-eslint/parser
npm install --save-dev eslint-config-prettier eslint-plugin-prettier

# 3. 初始化 GTS
npx gts init

# 4. 安装思源笔记专用工具
npm install --save-dev siyuan-plugin-cli

# 5. 安装项目依赖
pnpm install
```

### package.json 完整配置

```json
{
  "name": "my-siyuan-plugin",
  "version": "0.1.0",
  "description": "My SiYuan Plugin with Google Standards",
  "author": "Your Name",
  "scripts": {
    "dev": "vite build --watch",
    "build": "vite build && node scripts/make-package.js",
    "lint": "gts lint && eslint . --ext .ts,.svelte",
    "fix": "gts fix && eslint . --ext .ts,.svelte --fix",
    "format": "prettier --write .",
    "check": "svelte-check --tsconfig ./tsconfig.json",
    "make-link": "npx make-link",
    "make-install": "npx make-install",
    "pre-commit": "npm run format && npm run lint && npm run check",
    "clean": "gts clean",
    "compile": "tsc",
    "prepare": "npm run build"
  },
  "dependencies": {
    "siyuan": "^3.1.10"
  },
  "devDependencies": {
    "gts": "^6.0.2",
    "@types/node": "^22.0.0",
    "@typescript-eslint/eslint-plugin": "^8.0.0",
    "@typescript-eslint/parser": "^8.0.0",
    "eslint": "^8.57.0",
    "eslint-plugin-svelte": "^3.10.1",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.2.0",
    "prettier": "^3.3.0",
    "prettier-plugin-svelte": "^3.2.6",
    "svelte": "^4.2.18",
    "svelte-check": "^3.8.4",
    "svelte-eslint-parser": "^0.41.0",
    "typescript": "^5.5.0",
    "vite": "^5.3.0",
    "vite-plugin-static-copy": "^1.0.6",
    "@vite/plugin-legacy": "^5.4.1",
    "terser": "^5.31.0",
    "sass": "^1.77.0",
    "minimist": "^1.2.8",
    "ts-node": "^10.9.2"
  }
}
```

### ESLint 配置 (eslint.config.js)

```javascript
import js from '@eslint/js';
import svelte from 'eslint-plugin-svelte';
import tseslint from '@typescript-eslint/typescript-eslint';
import prettier from 'eslint-config-prettier';

export default tseslint.config(
  js.configs.recommended,
  ...tseslint.configs.recommended,
  ...svelte.configs.recommended,
  prettier,
  {
    files: ['**/*.svelte'],
    languageOptions: {
      parserOptions: {
        parser: tseslint.parser,
        extraFileExtensions: ['.svelte']
      }
    }
  },
  {
    ignores: [
      'node_modules/',
      'dist/',
      'build/',
      'temp/',
      '*.config.js',
      'scripts/',
      'public/'
    ]
  },
  {
    rules: {
      // Google TypeScript Style 规则
      '@typescript-eslint/no-unused-vars': ['error', { 
        argsIgnorePattern: '^_',
        varsIgnorePattern: '^_',
        caughtErrorsIgnorePattern: '^_'
      }],
      '@typescript-eslint/explicit-function-return-type': 'warn',
      '@typescript-eslint/no-explicit-any': 'error',
      '@typescript-eslint/prefer-const': 'error',
      '@typescript-eslint/no-var-requires': 'error',
      
      // 禁用 Google Style 禁止的特性
      '@typescript-eslint/no-namespace': 'error',
      '@typescript-eslint/ban-ts-comment': 'error',
      
      // Svelte 特定规则
      'svelte/indent': ['error', { indent: 2 }],
      'svelte/max-attributes-per-line': ['error', { max: 1 }],
      'svelte/html-self-closing': 'error',
      'svelte/shorthand-attribute': 'error',
      'svelte/shorthand-directive': 'error',
      'svelte/prefer-destructuring-props': 'error',
      
      // 通用规则
      'prefer-const': 'error',
      'no-var': 'error',
      'eqeqeq': ['error', 'always', { null: 'ignore' }],
      'no-eval': 'error',
      'no-implied-eval': 'error',
      'prefer-arrow-callback': 'error',
      'arrow-body-style': ['error', 'as-needed'],
      
      // 命名约定
      'camelcase': ['error', { properties: 'never' }],
      
      // 思源笔记特定规则
      'no-console': ['warn', { allow: ['warn', 'error'] }]
    }
  },
  {
    files: ['**/*.ts', '**/*.tsx'],
    rules: {
      // TypeScript 文件特定规则
      '@typescript-eslint/explicit-member-accessibility': 'error',
      '@typescript-eslint/member-ordering': 'error',
      '@typescript-eslint/prefer-readonly': 'error'
    }
  },
  {
    files: ['**/*.svelte'],
    rules: {
      // Svelte 文件中可以放宽一些 TypeScript 规则
      '@typescript-eslint/explicit-function-return-type': 'off'
    }
  }
);
```

### TypeScript 配置 (tsconfig.json)

```json
{
  "extends": "./node_modules/gts/tsconfig-google.json",
  "compilerOptions": {
    "rootDir": ".",
    "outDir": "build",
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitOverride": true,
    "exactOptionalPropertyTypes": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "useUnknownInCatchVariables": true,
    "alwaysStrict": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": false,
    "experimentalDecorators": false,
    "emitDecoratorMetadata": false,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@components/*": ["src/components/*"],
      "@utils/*": ["src/utils/*"],
      "@types/*": ["src/types/*"]
    }
  },
  "include": [
    "src/**/*.ts",
    "src/**/*.svelte",
    "src/**/*.d.ts",
    "vite.config.ts"
  ],
  "exclude": [
    "node_modules",
    "build",
    "dist",
    "temp"
  ],
  "references": [
    {
      "path": "./tsconfig.node.json"
    }
  ]
}
```

### Prettier 配置 (.prettierrc.js)

```javascript
module.exports = {
  // Google Style 偏好设置
  singleQuote: true,
  semi: true,
  trailingComma: 'es5',
  tabWidth: 2,
  useTabs: false,
  printWidth: 80,
  bracketSpacing: false,
  arrowParens: 'avoid',
  endOfLine: 'lf',
  
  // Svelte 特定设置
  plugins: ['prettier-plugin-svelte'],
  svelteSortOrder: 'options-styles-scripts-markup',
  svelteStrictMode: false,
  svelteBracketNewLine: true,
  svelteIndentScriptAndStyle: true,
  svelteAllowShorthand: true,
  
  // 文件特定覆盖
  overrides: [
    {
      files: '*.svelte',
      options: {
        parser: 'svelte',
        printWidth: 100 // Svelte 文件可以稍微宽一些
      }
    },
    {
      files: ['*.json', '*.yaml', '*.yml'],
      options: {
        tabWidth: 2
      }
    }
  ]
};
```

### Vite 配置优化 (vite.config.ts)

```typescript
import {defineConfig} from 'vite';
import {svelte} from '@sveltejs/vite-plugin-svelte';
import {viteStaticCopy} from 'vite-plugin-static-copy';
import legacy from '@vitejs/plugin-legacy';
import {resolve} from 'path';
import minimist from 'minimist';

const args = minimist(process.argv.slice(2));
const isWatch = args.watch || args.w || false;

export default defineConfig({
  plugins: [
    svelte({
      compilerOptions: {
        dev: isWatch,
        css: 'injected'
      },
      emitCss: false
    }),
    viteStaticCopy({
      targets: [
        {src: 'README*.md', dest: './'},
        {src: 'plugin.json', dest: './'},
        {src: 'preview.png', dest: './'},
        {src: 'icon.png', dest: './'},
        {src: 'public/i18n/**', dest: './i18n/'}
      ]
    }),
    legacy({
      targets: ['chrome >= 88'],
      modernPolyfills: false
    })
  ],
  define: {
    'process.env.NODE_ENV': JSON.stringify(
      isWatch ? 'development' : 'production'
    ),
    'process.env.DEV_MODE': JSON.stringify(isWatch)
  },
  build: {
    outDir: isWatch ? 'dev' : 'dist',
    emptyOutDir: false,
    minify: !isWatch,
    sourcemap: isWatch ? 'inline' : false,
    lib: {
      entry: resolve(__dirname, 'src/index.ts'),
      fileName: 'index',
      formats: ['cjs']
    },
    rollupOptions: {
      external: ['siyuan'],
      output: {
        entryFileNames: '[name].js',
        assetFileNames: assetInfo => {
          if (assetInfo.name?.endsWith('.css')) {
            return 'index.css';
          }
          return '[name].[ext]';
        }
      }
    },
    target: 'esnext',
    cssCodeSplit: false
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
      '@components': resolve(__dirname, 'src/components'),
      '@utils': resolve(__dirname, 'src/utils'),
      '@types': resolve(__dirname, 'src/types')
    }
  },
  server: {
    host: 'localhost',
    port: 3000,
    strictPort: true
  }
});
```

## 📂 推荐的项目结构

```
my-plugin/
├── src/                          # 源代码目录
│   ├── index.ts                  # 插件入口点 (UpperCamelCase class)
│   ├── components/               # Svelte 组件 (PascalCase)
│   │   ├── SettingsPanel.svelte
│   │   ├── PluginDialog.svelte
│   │   └── index.ts              # 组件导出
│   ├── utils/                    # 工具函数 (camelCase)
│   │   ├── apiClient.ts
│   │   ├── constants.ts
│   │   ├── helpers.ts
│   │   └── index.ts
│   ├── types/                    # 类型定义
│   │   ├── plugin-types.ts
│   │   ├── api-types.ts
│   │   └── index.ts
│   ├── stores/                   # Svelte stores
│   │   ├── pluginStore.ts
│   │   └── index.ts
│   └── styles/                   # 样式文件
│       ├── global.scss
│       └── components.scss
├── public/                       # 静态资源
│   ├── i18n/                     # 国际化文件
│   │   ├── en_US.yaml
│   │   ├── zh_CN.yaml
│   │   └── zh_CHT.yaml
│   ├── icon.png                  # 插件图标
│   └── preview.png               # 预览图
├── scripts/                      # 构建脚本
│   ├── make-package.js
│   └── make-dev-link.js
├── dist/                         # 构建输出 (生产)
├── dev/                          # 开发输出
├── plugin.json                   # 插件配置
├── vite.config.ts               # Vite 配置
├── tsconfig.json                # TypeScript 配置
├── eslint.config.js             # ESLint 配置
├── .prettierrc.js               # Prettier 配置
├── .gitignore
└── README.md
```

## 🎯 Google TypeScript 命名规范详解

### 标识符命名规则

TypeScript 中的标识符必须只使用 ASCII 字母、数字、下划线（用于常量和结构化测试方法名）和 '$' 符号。每个有效的标识符名称都由正则表达式 `[$\w]+` 匹配。

| 风格 | 使用场景 | 示例 |
|------|---------|------|
| `UpperCamelCase` | 类、接口、类型、枚举、装饰器、类型参数 | `UserProfile`, `ApiResponse`, `PluginSettings` |
| `lowerCamelCase` | 变量、参数、函数、方法、属性、模块别名 | `userName`, `getUserData()`, `isEnabled` |
| `CONSTANT_CASE` | 全局常量值，包括枚举值 | `MAX_RETRY_COUNT`, `API_BASE_URL` |

### 思源笔记特定命名约定

```typescript
// 插件主类命名 (UpperCamelCase)
export default class MyAwesomePlugin extends Plugin {
  // 私有字段 (lowerCamelCase with private)
  private readonly settingsPanel: SettingsPanel;
  private readonly apiClient: ApiClient;
  
  // 常量 (CONSTANT_CASE)
  private static readonly MAX_CACHE_SIZE = 100;
  private static readonly DEFAULT_TIMEOUT = 5000;
  
  // 公共方法 (lowerCamelCase)
  async onload(): Promise<void> {
    await this.initializePlugin();
  }
  
  // 私有方法 (lowerCamelCase)
  private async initializePlugin(): Promise<void> {
    // 实现代码
  }
  
  // 事件处理器 (lowerCamelCase)
  private handleSettingsChange = (settings: PluginSettings): void => {
    this.updateConfiguration(settings);
  };
}
```

### 文件和目录命名

```typescript
// 文件命名使用 camelCase
src/
├── pluginManager.ts         // ✓ 正确
├── apiClientUtils.ts        // ✓ 正确  
├── plugin_manager.ts        // ✗ 避免下划线
├── PluginManager.ts         // ✗ 避免 PascalCase

// 组件文件使用 PascalCase (Svelte 约定)
components/
├── SettingsPanel.svelte     // ✓ 正确
├── UserProfile.svelte       // ✓ 正确
├── settingsPanel.svelte     // ✗ 避免 camelCase
```

## 🔧 核心 TypeScript 编码规范

### 变量声明和类型注解

```typescript
// ✓ 正确：使用 const 和 let，避免 var
const API_ENDPOINT = 'https://api.example.com';
let currentUser: User | null = null;

// ✓ 正确：类型推断足够时省略类型注解
const isEnabled = true;  // 类型推断为 boolean
const users = new Set<string>();  // 明确泛型类型

// ✗ 错误：不必要的类型注解
const isEnabled: boolean = true;
const users: Set<string> = new Set<string>();

// ✓ 正确：复杂类型需要注解
const config: PluginConfig = await loadConfig();
const response: ApiResponse<UserData> = await fetchUserData();
```

### 函数声明和箭头函数

对于命名函数，优先使用函数声明而不是箭头函数或函数表达式。箭头函数可以在需要显式类型注解时使用。

```typescript
// ✓ 正确：函数声明用于命名函数
function processUserData(userData: UserData): ProcessedData {
  return {
    id: userData.id,
    name: userData.name.trim(),
    email: userData.email.toLowerCase()
  };
}

// ✓ 正确：箭头函数用于需要类型注解的场景
interface SearchFunction {
  (source: string, pattern: string): boolean;
}

const searchInText: SearchFunction = (source, pattern) => {
  return source.includes(pattern);
};

// ✓ 正确：方法体中使用箭头函数（访问外部 this）
class PluginManager {
  private plugins: Plugin[] = [];
  
  loadPlugins(): void {
    // 箭头函数保持 this 绑定
    this.plugins.forEach(plugin => {
      plugin.initialize();
    });
  }
  
  // ✓ 正确：事件处理器使用箭头函数属性
  private handlePluginError = (error: Error): void => {
    console.error('Plugin error:', error.message);
  };
}
```

### 类和接口定义

```typescript
// ✓ 正确：类定义
class SiYuanPlugin extends Plugin {
  // 字段初始化（优先在声明处初始化）
  private readonly eventHandlers: Map<string, Function> = new Map();
  private isInitialized = false;
  
  // 参数属性（减少样板代码）
  constructor(
    private readonly config: PluginConfig,
    private readonly logger: Logger
  ) {
    super();
  }
  
  // 方法声明间用空行分隔
  async onload(): Promise<void> {
    await this.initializeComponents();
    this.isInitialized = true;
  }
  
  private async initializeComponents(): Promise<void> {
    // 实现代码
  }
}

// ✓ 正确：接口定义（优先于类型别名）
interface PluginSettings {
  readonly apiKey: string;
  readonly enableDebug: boolean;
  readonly maxRetries: number;
  readonly themes?: string[];  // 可选属性使用 ?
}

// ✓ 正确：使用结构化类型
const settings: PluginSettings = {
  apiKey: 'sk-xxx',
  enableDebug: false,
  maxRetries: 3
};

// ✗ 错误：避免 default exports
export default class MyPlugin { }  // 不推荐

// ✓ 正确：使用 named exports
export class MyPlugin { }
```

### 导入和导出规范

使用命名导出而不是默认导出。这确保所有导入遵循统一模式。

```typescript
// ✓ 正确：命名导入/导出
// utils/apiClient.ts
export const API_BASE_URL = 'https://api.siyuan.com';

export interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

export class ApiClient {
  async get<T>(endpoint: string): Promise<ApiResponse<T>> {
    // 实现
  }
}

// 使用时
import {ApiClient, ApiResponse, API_BASE_URL} from '@/utils/apiClient';

// ✓ 正确：命名空间导入（大量符号时）
import * as apiUtils from '@/utils/apiClient';
const client = new apiUtils.ApiClient();

// ✓ 正确：类型导入
import type {PluginSettings} from '@/types/plugin-types';
import type {User} from '@/types/user-types';

// ✗ 错误：避免默认导出
export default class ApiClient { }  // 不推荐
import ApiClient from '@/utils/apiClient';  // 不推荐
```

### 错误处理和类型安全

```typescript
// ✓ 正确：抛出 Error 实例
function validateUserInput(input: unknown): UserInput {
  if (!isValidUserInput(input)) {
    throw new Error('Invalid user input format');
  }
  return input;
}

// ✓ 正确：类型守卫而不是类型断言
function isValidUserInput(input: unknown): input is UserInput {
  return typeof input === 'object' && 
         input !== null && 
         'name' in input && 
         'email' in input;
}

// ✓ 正确：catch 块中的错误处理
async function loadPluginData(): Promise<PluginData> {
  try {
    const response = await fetch('/api/plugin-data');
    return await response.json();
  } catch (error: unknown) {
    // 断言错误类型
    if (error instanceof Error) {
      console.error('Failed to load plugin data:', error.message);
      throw error;
    }
    throw new Error('Unknown error occurred');
  }
}

// ✓ 正确：使用 unknown 而不是 any
function processApiResponse(data: unknown): ProcessedData {
  // 类型收窄
  if (isApiResponseData(data)) {
    return processValidData(data);
  }
  throw new Error('Invalid API response format');
}
```

## 🎨 Svelte 组件编码规范

### 组件结构和风格

```svelte
<!-- ✓ 正确：Svelte 组件结构 -->
<script lang="ts">
  // 1. 导入语句
  import type {Plugin} from 'siyuan';
  import type {PluginSettings} from '@/types/plugin-types';
  import {createEventDispatcher} from 'svelte';
  import Button from '@/components/Button.svelte';
  
  // 2. 导出的 props（明确类型）
  export let plugin: Plugin;
  export let settings: PluginSettings;
  export let isVisible = false;
  
  // 3. 事件分发器
  const dispatch = createEventDispatcher<{
    save: PluginSettings;
    cancel: void;
    error: {message: string};
  }>();
  
  // 4. 本地状态
  let isLoading = false;
  let errorMessage: string | null = null;
  let formData = {...settings};
  
  // 5. 响应式声明
  $: isFormValid = formData.apiKey.length > 0 && formData.maxRetries > 0;
  $: canSave = isFormValid && !isLoading;
  
  // 6. 函数定义（明确返回类型）
  async function handleSave(): Promise<void> {
    isLoading = true;
    errorMessage = null;
    
    try {
      await validateSettings(formData);
      dispatch('save', formData);
      plugin.showMessage('Settings saved successfully');
    } catch (error: unknown) {
      if (error instanceof Error) {
        errorMessage = error.message;
        dispatch('error', {message: error.message});
      } else {
        errorMessage = 'An unknown error occurred';
      }
    } finally {
      isLoading = false;
    }
  }
  
  function handleCancel(): void {
    formData = {...settings};  // 重置表单
    dispatch('cancel');
  }
  
  function validateSettings(data: PluginSettings): void {
    if (!data.apiKey.trim()) {
      throw new Error('API Key is required');
    }
    if (data.maxRetries < 1 || data.maxRetries > 10) {
      throw new Error('Max retries must be between 1 and 10');
    }
  }
</script>

<!-- ✓ 正确：HTML 模板 -->
<div class="settings-panel" class:visible={isVisible}>
  <header class="panel-header">
    <h2>{plugin.i18n.settingsTitle}</h2>
  </header>
  
  <main class="panel-content">
    {#if errorMessage}
      <div class="error-message" role="alert">
        {errorMessage}
      </div>
    {/if}
    
    <form on:submit|preventDefault={handleSave}>
      <div class="form-group">
        <label for="api-key">{plugin.i18n.apiKeyLabel}</label>
        <input
          id="api-key"
          type="password"
          bind:value={formData.apiKey}
          placeholder={plugin.i18n.apiKeyPlaceholder}
          required
        />
      </div>
      
      <div class="form-group">
        <label for="max-retries">{plugin.i18n.maxRetriesLabel}</label>
        <input
          id="max-retries"
          type="number"
          bind:value={formData.maxRetries}
          min="1"
          max="10"
          required
        />
      </div>
      
      <div class="form-group checkbox-group">
        <label>
          <input
            type="checkbox"
            bind:checked={formData.enableDebug}
          />
          {plugin.i18n.enableDebugLabel}
        </label>
      </div>
    </form>
  </main>
  
  <footer class="panel-actions">
    <Button
      variant="secondary"
      on:click={handleCancel}
      disabled={isLoading}
    >
      {plugin.i18n.cancel}
    </Button>
    
    <Button
      variant="primary"
      on:click={handleSave}
      disabled={!canSave}
      loading={isLoading}
    >
      {isLoading ? plugin.i18n.saving : plugin.i18n.save}
    </Button>
  </footer>
</div>

<!-- ✓ 正确：样式定义 -->
<style lang="scss">
  .settings-panel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 480px;
    max-height: 80vh;
    background: var(--b3-theme-background);
    border: 1px solid var(--b3-theme-border);
    border-radius: 8px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    display: none;
    
    &.visible {
      display: flex;
      flex-direction: column;
    }
  }
  
  .panel-header {
    padding: 16px 20px;
    border-bottom: 1px solid var(--b3-theme-border);
    
    h2 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      color: var(--b3-theme-on-background);
    }
  }
  
  .panel-content {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
  }
  
  .error-message {
    padding: 8px 12px;
    margin-bottom: 16px;
    background: var(--b3-theme-error-lighter);
    color: var(--b3-theme-error);
    border: 1px solid var(--b3-theme-error-light);
    border-radius: 4px;
    font-size: 14px;
  }
  
  .form-group {
    margin-bottom: 16px;
    
    label {
      display: block;
      margin-bottom: 4px;
      font-size: 14px;
      font-weight: 500;
      color: var(--b3-theme-on-background);
    }
    
    input[type="text"],
    input[type="password"],
    input[type="number"] {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid var(--b3-theme-border);
      border-radius: 4px;
      font-size: 14px;
      background: var(--b3-theme-surface);
      color: var(--b3-theme-on-surface);
      
      &:focus {
        outline: none;
        border-color: var(--b3-theme-primary);
        box-shadow: 0 0 0 2px var(--b3-theme-primary-light);
      }
    }
    
    &.checkbox-group {
      label {
        display: flex;
        align-items: center;
        cursor: pointer;
        
        input[type="checkbox"] {
          margin-right: 8px;
        }
      }
    }
  }
  
  .panel-actions {
    padding: 16px 20px;
    border-top: 1px solid var(--b3-theme-border);
    display: flex;
    justify-content: flex-end;
    gap: 8px;
  }
</style>
```

### Svelte Store 模式

```typescript
// stores/pluginStore.ts
import {writable, derived, readable} from 'svelte/store';
import type {Plugin} from 'siyuan';
import type {PluginSettings, PluginState} from '@/types/plugin-types';

// ✓ 正确：类型化的 stores
export const pluginInstance = writable<Plugin | null>(null);

export const pluginSettings = writable<PluginSettings>({
  apiKey: '',
  enableDebug: false,
  maxRetries: 3,
  theme: 'auto'
});

export const pluginState = writable<PluginState>({
  isLoading: false,
  isInitialized: false,
  lastError: null,
  connectionStatus: 'disconnected'
});

// ✓ 正确：派生 stores
export const isPluginReady = derived(
  [pluginInstance, pluginState],
  ([$plugin, $state]) => $plugin !== null && $state.isInitialized
);

export const hasValidSettings = derived(
  pluginSettings,
  $settings => $settings.apiKey.length > 0 && $settings.maxRetries > 0
);

// ✓ 正确：异步 stores
export function createAsyncStore<T>(
  initialValue: T,
  fetcher: () => Promise<T>
) {
  const store = writable<{
    data: T;
    loading: boolean;
    error: Error | null;
  }>({
    data: initialValue,
    loading: false,
    error: null
  });

  const load = async (): Promise<void> => {
    store.update(state => ({...state, loading: true, error: null}));
    
    try {
      const data = await fetcher();
      store.update(state => ({...state, data, loading: false}));
    } catch (error: unknown) {
      const errorInstance = error instanceof Error 
        ? error 
        : new Error('Unknown error');
      store.update(state => ({...state, loading: false, error: errorInstance}));
    }
  };

  return {
    subscribe: store.subscribe,
    load
  };
}

// 使用示例
export const userDataStore = createAsyncStore(
  null as UserData | null,
  () => fetchUserData()
);
```

## 🌍 国际化最佳实践

### 多语言文件结构

```yaml
# public/i18n/en_US.yaml
plugin:
  name: "My Awesome Plugin"
  description: "A powerful plugin for SiYuan"

ui:
  buttons:
    save: "Save"
    cancel: "Cancel"
    reset: "Reset"
    delete: "Delete"
  
  labels:
    apiKey: "API Key"
    maxRetries: "Max Retries"
    enableDebug: "Enable Debug Mode"
    theme: "Theme"
  
  messages:
    saveSuccess: "Settings saved successfully"
    saveError: "Failed to save settings: {0}"
    loadError: "Failed to load data: {0}"
    networkError: "Network connection failed"
  
  placeholders:
    apiKeyPlaceholder: "Enter your API key"
    searchPlaceholder: "Search..."

settings:
  title: "Plugin Settings"
  sections:
    general: "General"
    advanced: "Advanced"
    about: "About"

errors:
  invalidApiKey: "Invalid API key format"
  rateLimitExceeded: "Rate limit exceeded. Please try again later."
  networkTimeout: "Request timed out"
```

```yaml
# public/i18n/zh_CN.yaml
plugin:
  name: "我的强大插件"
  description: "一个为思源笔记设计的强大插件"

ui:
  buttons:
    save: "保存"
    cancel: "取消"  
    reset: "重置"
    delete: "删除"
  
  labels:
    apiKey: "API 密钥"
    maxRetries: "最大重试次数"
    enableDebug: "启用调试模式"
    theme: "主题"
  
  messages:
    saveSuccess: "设置保存成功"
    saveError: "保存设置失败：{0}"
    loadError: "加载数据失败：{0}"
    networkError: "网络连接失败"
  
  placeholders:
    apiKeyPlaceholder: "请输入您的 API 密钥"
    searchPlaceholder: "搜索..."

settings:
  title: "插件设置"
  sections:
    general: "常规"
    advanced: "高级"
    about: "关于"

errors:
  invalidApiKey: "API 密钥格式无效"
  rateLimitExceeded: "请求频率超限，请稍后重试"
  networkTimeout: "请求超时"
```

### 国际化工具函数

```typescript
// utils/i18n.ts
import type {Plugin} from 'siyuan';

export class I18nManager {
  constructor(private readonly plugin: Plugin) {}

  /**
   * 获取翻译文本，支持参数替换
   * @param key 翻译键，支持点分隔的嵌套键
   * @param params 参数数组，用于替换 {0}, {1} 等占位符
   */
  t(key: string, ...params: (string | number)[]): string {
    const translation = this.getNestedValue(this.plugin.i18n, key);
    
    if (typeof translation !== 'string') {
      console.warn(`Translation not found for key: ${key}`);
      return key;
    }
    
    return this.replacePlaceholders(translation, params);
  }

  /**
   * 获取嵌套对象值
   */
  private getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => {
      return current && current[key] !== undefined ? current[key] : undefined;
    }, obj);
  }

  /**
   * 替换占位符
   */
  private replacePlaceholders(
    text: string, 
    params: (string | number)[]
  ): string {
    return text.replace(/{(\d+)}/g, (match, index) => {
      const paramIndex = parseInt(index, 10);
      return paramIndex < params.length 
        ? String(params[paramIndex])
        : match;
    });
  }

  /**
   * 获取当前语言代码
   */
  getCurrentLanguage(): string {
    return this.plugin.data[':storage'] || 'en_US';
  }

  /**
   * 检查是否为中文环境
   */
  isChinese(): boolean {
    return this.getCurrentLanguage().startsWith('zh');
  }
}

// 使用示例
export function createI18nHelper(plugin: Plugin) {
  const i18n = new I18nManager(plugin);
  
  return {
    t: i18n.t.bind(i18n),
    getCurrentLanguage: i18n.getCurrentLanguage.bind(i18n),
    isChinese: i18n.isChinese.bind(i18n)
  };
}
```

### 组件中的国际化使用

```svelte
<script lang="ts">
  import type {Plugin} from 'siyuan';
  import {createI18nHelper} from '@/utils/i18n';
  
  export let plugin: Plugin;
  
  const {t} = createI18nHelper(plugin);
  
  let errorCount = 0;
  let username = 'John';
  
  function handleError() {
    errorCount++;
    // 使用参数替换
    const message = t('ui.messages.saveError', 'Network timeout');
    plugin.showMessage(message, 3000, 'error');
  }
</script>

<div class="user-panel">
  <h2>{t('settings.title')}</h2>
  
  <div class="user-info">
    <span>{t('ui.labels.username')}: {username}</span>
    {#if errorCount > 0}
      <span class="error-count">
        {t('ui.messages.errorCount', errorCount)}
      </span>
    {/if}
  </div>
  
  <button on:click={handleError}>
    {t('ui.buttons.test')}
  </button>
</div>
```

## 🔌 思源笔记 API 集成规范

### 内核 API 使用

```typescript
// utils/siYuanApi.ts
import type {Plugin} from 'siyuan';

export class SiYuanApiClient {
  constructor(private readonly plugin: Plugin) {}

  /**
   * 查询块数据
   */
  async queryBlocks(sql: string): Promise<Block[]> {
    try {
      const response = await this.plugin.kernelApi('/api/query/sql', {
        stmt: sql
      });
      
      if (response.code !== 0) {
        throw new Error(`API Error: ${response.msg}`);
      }
      
      return response.data || [];
    } catch (error: unknown) {
      if (error instanceof Error) {
        console.error('Failed to query blocks:', error.message);
        throw error;
      }
      throw new Error('Unknown error in queryBlocks');
    }
  }

  /**
   * 获取文件内容
   */
  async getFile(path: string): Promise<string> {
    try {
      const response = await this.plugin.kernelApi('/api/file/getFile', {
        path
      });
      
      if (response.code !== 0) {
        throw new Error(`Failed to get file: ${response.msg}`);
      }
      
      return response.data;
    } catch (error: unknown) {
      if (error instanceof Error) {
        console.error(`Failed to get file ${path}:`, error.message);
        throw error;
      }
      throw new Error('Unknown error in getFile');
    }
  }

  /**
   * 保存文件内容
   */
  async putFile(path: string, content: string): Promise<void> {
    try {
      const response = await this.plugin.kernelApi('/api/file/putFile', {
        path,
        file: content
      });
      
      if (response.code !== 0) {
        throw new Error(`Failed to save file: ${response.msg}`);
      }
    } catch (error: unknown) {
      if (error instanceof Error) {
        console.error(`Failed to save file ${path}:`, error.message);
        throw error;
      }
      throw new Error('Unknown error in putFile');
    }
  }

  /**
   * 插入块
   */
  async insertBlock(
    dataType: 'markdown' | 'dom',
    data: string,
    parentID?: string
  ): Promise<Block[]> {
    try {
      const response = await this.plugin.kernelApi('/api/block/insertBlock', {
        dataType,
        data,
        parentID
      });
      
      if (response.code !== 0) {
        throw new Error(`Failed to insert block: ${response.msg}`);
      }
      
      return response.data || [];
    } catch (error: unknown) {
      if (error instanceof Error) {
        console.error('Failed to insert block:', error.message);
        throw error;
      }
      throw new Error('Unknown error in insertBlock');
    }
  }

  /**
   * 获取块信息
   */
  async getBlockInfo(id: string): Promise<Block | null> {
    try {
      const blocks = await this.queryBlocks(
        `SELECT * FROM blocks WHERE id = '${id}'`
      );
      return blocks.length > 0 ? blocks[0] : null;
    } catch (error: unknown) {
      if (error instanceof Error) {
        console.error(`Failed to get block info for ${id}:`, error.message);
        throw error;
      }
      throw new Error('Unknown error in getBlockInfo');
    }
  }

  /**
   * 获取文档树
   */
  async getDocTree(): Promise<FileTreeNode[]> {
    try {
      const response = await this.plugin.kernelApi('/api/filetree/getDoc', {});
      
      if (response.code !== 0) {
        throw new Error(`Failed to get doc tree: ${response.msg}`);
      }
      
      return response.data || [];
    } catch (error: unknown) {
      if (error instanceof Error) {
        console.error('Failed to get doc tree:', error.message);
        throw error;
      }
      throw new Error('Unknown error in getDocTree');
    }
  }
}

// 类型定义
interface Block {
  id: string;
  parent_id: string;
  root_id: string;
  hash: string;
  box: string;
  path: string;
  hpath: string;
  name: string;
  alias: string;
  memo: string;
  tag: string;
  content: string;
  markdown: string;
  length: number;
  type: string;
  subtype: string;
  ial: string;
  sort: number;
  created: string;
  updated: string;
}

interface FileTreeNode {
  id: string;
  name: string;
  type: string;
  path: string;
  children?: FileTreeNode[];
}
```

### 插件生命周期管理

```typescript
// src/index.ts
import {Plugin} from 'siyuan';
import type {PluginSettings} from '@/types/plugin-types';
import {SiYuanApiClient} from '@/utils/siYuanApi';
import {createI18nHelper} from '@/utils/i18n';
import SettingsPanel from '@/components/SettingsPanel.svelte';

export default class MyAwesomePlugin extends Plugin {
  private readonly apiClient: SiYuanApiClient;
  private readonly i18nHelper: ReturnType<typeof createI18nHelper>;
  private settingsPanel: SettingsPanel | null = null;
  private eventHandlers: Map<string, Function> = new Map();

  // 默认设置
  private static readonly DEFAULT_SETTINGS: PluginSettings = {
    apiKey: '',
    enableDebug: false,
    maxRetries: 3,
    theme: 'auto'
  };

  constructor() {
    super();
    this.apiClient = new SiYuanApiClient(this);
    this.i18nHelper = createI18nHelper(this);
  }

  async onload(): Promise<void> {
    console.log('Loading MyAwesome Plugin...');

    try {
      await this.initializePlugin();
      await this.registerEventHandlers();
      this.addTopBarIcon();
      
      console.log('MyAwesome Plugin loaded successfully');
    } catch (error: unknown) {
      if (error instanceof Error) {
        console.error('Failed to load plugin:', error.message);
        this.showMessage(`Plugin load failed: ${error.message}`, 5000, 'error');
      }
    }
  }

  onunload(): void {
    console.log('Unloading MyAwesome Plugin...');
    
    // 清理资源
    this.cleanupEventHandlers();
    this.destroySettingsPanel();
    
    console.log('MyAwesome Plugin unloaded');
  }

  async onLayoutReady(): Promise<void> {
    console.log('Layout ready, performing additional initialization...');
    
    try {
      await this.loadUserData();
    } catch (error: unknown) {
      if (error instanceof Error) {
        console.error('Failed to load user data:', error.message);
      }
    }
  }

  private async initializePlugin(): Promise<void> {
    // 加载设置
    const savedSettings = await this.loadData();
    const settings: PluginSettings = {
      ...MyAwesomePlugin.DEFAULT_SETTINGS,
      ...savedSettings
    };
    
    // 验证设置
    this.validateSettings(settings);
    
    // 保存合并后的设置
    await this.saveData(settings);
  }

  private validateSettings(settings: PluginSettings): void {
    if (settings.maxRetries < 1 || settings.maxRetries > 10) {
      throw new Error('Max retries must be between 1 and 10');
    }
    
    if (settings.apiKey && !/^sk-[a-zA-Z0-9]{32,}$/.test(settings.apiKey)) {
      console.warn('API key format appears invalid');
    }
  }

  private async registerEventHandlers(): Promise<void> {
    // 注册事件处理器
    const documentHandler = this.handleDocumentChange.bind(this);
    const blockHandler = this.handleBlockUpdate.bind(this);
    
    this.eventBus.on('switch-protyle', documentHandler);
    this.eventBus.on('input-block', blockHandler);
    
    // 保存引用以便清理
    this.eventHandlers.set('switch-protyle', documentHandler);
    this.eventHandlers.set('input-block', blockHandler);
  }

  private cleanupEventHandlers(): void {
    this.eventHandlers.forEach((handler, event) => {
      this.eventBus.off(event, handler);
    });
    this.eventHandlers.clear();
  }

  private addTopBarIcon(): void {
    this.addTopBar({
      icon: 'iconPlugin',
      title: this.i18nHelper.t('plugin.name'),
      position: 'right',
      callback: () => this.showSettingsPanel()
    });
  }

  private showSettingsPanel(): void {
    if (this.settingsPanel) {
      this.destroySettingsPanel();
    }

    this.settingsPanel = new SettingsPanel({
      target: document.body,
      props: {
        plugin: this,
        isVisible: true
      }
    });

    // 监听事件
    this.settingsPanel.$on('save', this.handleSettingsSave.bind(this));
    this.settingsPanel.$on('cancel', this.destroySettingsPanel.bind(this));
  }

  private destroySettingsPanel(): void {
    if (this.settingsPanel) {
      this.settingsPanel.$destroy();
      this.settingsPanel = null;
    }
  }

  private async handleSettingsSave(event: CustomEvent<PluginSettings>): Promise<void> {
    try {
      const newSettings = event.detail;
      this.validateSettings(newSettings);
      
      await this.saveData(newSettings);
      this.showMessage(this.i18nHelper.t('ui.messages.saveSuccess'), 3000);
      this.destroySettingsPanel();
    } catch (error: unknown) {
      if (error instanceof Error) {
        this.showMessage(
          this.i18nHelper.t('ui.messages.saveError', error.message),
          5000,
          'error'
        );
      }
    }
  }

  private handleDocumentChange(event: any): void {
    console.log('Document changed:', event);
    // 处理文档切换逻辑
  }

  private handleBlockUpdate(event: any): void {
    console.log('Block updated:', event);
    // 处理块更新逻辑
  }

  private async loadUserData(): Promise<void> {
    try {
      const userData = await this.apiClient.queryBlocks(
        "SELECT * FROM blocks WHERE type = 'd' LIMIT 10"
      );
      console.log('Loaded user data:', userData.length);
    } catch (error: unknown) {
      if (error instanceof Error) {
        console.warn('Failed to load user data:', error.message);
      }
    }
  }

  // 公共 API 方法
  public async getSettings(): Promise<PluginSettings> {
    return await this.loadData() || MyAwesomePlugin.DEFAULT_SETTINGS;
  }

  public async updateSettings(newSettings: Partial<PluginSettings>): Promise<void> {
    const currentSettings = await this.getSettings();
    const mergedSettings = {...currentSettings, ...newSettings};
    
    this.validateSettings(mergedSettings);
    await this.saveData(mergedSettings);
  }
}
```

## 🧪 测试和调试配置

### Jest 测试配置

```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/src/__tests__/setup.ts'],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^@components/(.*)$': '<rootDir>/src/components/$1',
    '^@utils/(.*)$': '<rootDir>/src/utils/$1',
    '^@types/(.*)$': '<rootDir>/src/types/$1'
  },
  transform: {
    '^.+\\.svelte$': [
      'svelte-jester',
      {
        preprocess: true
      }
    ],
    '^.+\\.ts$': 'ts-jest'
  },
  moduleFileExtensions: ['js', 'ts', 'svelte'],
  testMatch: [
    '<rootDir>/src/**/__tests__/**/*.{js,ts}',
    '<rootDir>/src/**/*.{test,spec}.{js,ts}'
  ],
  collectCoverageFrom: [
    'src/**/*.{ts,svelte}',
    '!src/**/*.d.ts',
    '!src/__tests__/**/*'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};
```

### 测试示例

```typescript
// src/__tests__/utils/apiClient.test.ts
import {SiYuanApiClient} from '@/utils/siYuanApi';
import type {Plugin} from 'siyuan';

describe('SiYuanApiClient', () => {
  let mockPlugin: jest.Mocked<Plugin>;
  let apiClient: SiYuanApiClient;

  beforeEach(() => {
    mockPlugin = {
      kernelApi: jest.fn(),
      showMessage: jest.fn()
    } as any;

    apiClient = new SiYuanApiClient(mockPlugin);
  });

  describe('queryBlocks', () => {
    it('should return blocks on successful query', async () => {
      const mockBlocks = [
        {id: '1', content: 'Test block 1'},
        {id: '2', content: 'Test block 2'}
      ];

      mockPlugin.kernelApi.mockResolvedValue({
        code: 0,
        data: mockBlocks
      });

      const result = await apiClient.queryBlocks('SELECT * FROM blocks');

      expect(result).toEqual(mockBlocks);
      expect(mockPlugin.kernelApi).toHaveBeenCalledWith('/api/query/sql', {
        stmt: 'SELECT * FROM blocks'
      });
    });

    it('should throw error on API failure', async () => {
      mockPlugin.kernelApi.mockResolvedValue({
        code: 1,
        msg: 'Database error'
      });

      await expect(
        apiClient.queryBlocks('INVALID SQL')
      ).rejects.toThrow('API Error: Database error');
    });

    it('should handle network errors', async () => {
      mockPlugin.kernelApi.mockRejectedValue(new Error('Network error'));

      await expect(
        apiClient.queryBlocks('SELECT * FROM blocks')
      ).rejects.toThrow('Network error');
    });
  });
});
```

### 调试配置

```json
// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug Plugin in SiYuan",
      "type": "node",
      "request": "attach",
      "port": 9229,
      "address": "localhost",
      "localRoot": "${workspaceFolder}/src",
      "remoteRoot": "/plugin-root/src",
      "skipFiles": ["<node_internals>/**"]
    },
    {
      "name": "Run Tests",
      "type": "node",
      "request": "launch",
      "program": "${workspaceFolder}/node_modules/.bin/jest",
      "args": ["--runInBand", "--no-cache"],
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen"
    }
  ]
}
```

### 开发环境配置

```json
// .vscode/settings.json
{
  "typescript.preferences.quoteStyle": "single",
  "typescript.format.semicolons": "insert",
  "typescript.suggest.autoImports": true,
  "typescript.updateImportsOnFileMove.enabled": "always",
  
  "eslint.validate": ["typescript", "svelte"],
  "eslint.workingDirectories": ["src"],
  
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": "explicit",
    "source.organizeImports": "explicit"
  },
  
  "[svelte]": {
    "editor.defaultFormatter": "svelte.svelte-vscode"
  },
  "[typescript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "[json]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  
  "svelte.enable-ts-plugin": true,
  "svelte.plugin.css.diagnostics.enable": true,
  "svelte.plugin.css.completions.enable": true,
  
  "files.associations": {
    "*.svelte": "svelte"
  },
  
  "emmet.includeLanguages": {
    "svelte": "html"
  }
}
```

## 🚀 构建和部署自动化

### GitHub Actions 工作流

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  release:
    types: [created]

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run linter
        run: npm run lint
        
      - name: Run type checking
        run: npm run check
        
      - name: Run tests
        run: npm test -- --coverage
        
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
          
  build:
    needs: lint-and-test
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build plugin
        run: npm run build
        
      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: plugin-build
          path: dist/
          
  release:
    if: github.event_name == 'release'
    needs: [lint-and-test, build]
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Build plugin
        run: npm run build
        
      - name: Create release package
        run: |
          cd dist
          zip -r ../plugin-release.zip .
          
      - name: Upload release asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: ./plugin-release.zip
          asset_name: plugin-release.zip
          asset_content_type: application/zip
```

### 开发脚本

```javascript
// scripts/make-package.js
const fs = require('fs');
const path = require('path');
const archiver = require('archiver');

async function createPackage() {
  const packageJson = JSON.parse(
    fs.readFileSync('package.json', 'utf8')
  );
  
  const pluginJson = JSON.parse(
    fs.readFileSync('plugin.json', 'utf8')
  );
  
  // 确保版本同步
  if (packageJson.version !== pluginJson.version) {
    console.warn('Version mismatch between package.json and plugin.json');
  }
  
  const distPath = path.resolve('dist');
  const packagePath = path.resolve(`${pluginJson.name}-${pluginJson.version}.zip`);
  
  if (!fs.existsSync(distPath)) {
    console.error('dist directory not found. Run build first.');
    process.exit(1);
  }
  
  const output = fs.createWriteStream(packagePath);
  const archive = archiver('zip', {zlib: {level: 9}});
  
  return new Promise((resolve, reject) => {
    output.on('close', () => {
      console.log(`Package created: ${packagePath} (${archive.pointer()} bytes)`);
      resolve();
    });
    
    archive.on('error', reject);
    archive.pipe(output);
    archive.directory(distPath, false);
    archive.finalize();
  });
}

createPackage().catch(console.error);
```

```javascript
// scripts/make-dev-link.js
const fs = require('fs');
const path = require('path');
const os = require('os');

function createSymlink() {
  const pluginJson = JSON.parse(
    fs.readFileSync('plugin.json', 'utf8')
  );
  
  const devPath = path.resolve('dev');
  const siyuanPath = getSiyuanPluginsPath();
  
  if (!siyuanPath) {
    console.error('SiYuan plugins directory not found');
    process.exit(1);
  }
  
  const targetPath = path.join(siyuanPath, pluginJson.name);
  
  try {
    if (fs.existsSync(targetPath)) {
      fs.rmSync(targetPath, {recursive: true, force: true});
    }
    
    fs.symlinkSync(devPath, targetPath, 'junction');
    console.log(`Symlink created: ${devPath} -> ${targetPath}`);
  } catch (error) {
    console.error('Failed to create symlink:', error.message);
    if (os.platform() === 'win32') {
      console.log('On Windows, try running as administrator');
    }
    process.exit(1);
  }
}

function getSiyuanPluginsPath() {
  const platform = os.platform();
  const homeDir = os.homedir();
  
  const paths = {
    win32: path.join(homeDir, 'AppData', 'Roaming', 'SiYuan', 'data', 'plugins'),
    darwin: path.join(homeDir, 'Library', 'Application Support', 'SiYuan', 'data', 'plugins'),
    linux: path.join(homeDir, '.config', 'SiYuan', 'data', 'plugins')
  };
  
  const siyuanPath = paths[platform];
  return fs.existsSync(siyuanPath) ? siyuanPath : null;
}

createSymlink();
```

## 📋 代码检查清单

在提交代码前，请确保通过以下检查：

### ✅ TypeScript 规范检查

- [ ] 所有变量使用 `const` 或 `let`，避免 `var`
- [ ] 函数有明确的返回类型注解
- [ ] 避免使用 `any` 类型，使用 `unknown` 代替
- [ ] 使用命名导出而不是默认导出
- [ ] 类型断言使用 `as` 语法而不是尖括号
- [ ] 错误处理使用 `Error` 实例而不是字符串
- [ ] 使用结构化类型和接口

### ✅ Svelte 组件检查

- [ ] 组件 script 部分按照推荐顺序组织
- [ ] Props 有明确的类型定义
- [ ] 事件分发器有类型约束
- [ ] 样式使用 CSS 变量适配主题
- [ ] 组件具有良好的可访问性

### ✅ 思源笔记特定检查

- [ ] 使用内核 API 而不是直接文件操作
- [ ] 支持多语言国际化
- [ ] 正确处理插件生命周期
- [ ] 清理事件监听器和资源
- [ ] 错误处理和用户反馈

### ✅ 代码质量检查

- [ ] 通过 ESLint 检查 (`npm run lint`)
- [ ] 通过 TypeScript 检查 (`npm run check`)
- [ ] 通过 Prettier 格式化 (`npm run format`)
- [ ] 测试覆盖率达到要求
- [ ] 文档和注释完整

## 🎉 总结

这份指南提供了一套完整的 Google 标准编码规范，专门针对思源笔记插件开发进行了优化。遵循这些规范将帮助你：

1. **编写高质量代码** - 遵循业界最佳实践
2. **提高可维护性** - 统一的代码风格和结构
3. **减少错误** - 严格的类型检查和错误处理
4. **提升开发效率** - 自动化工具链和开发流程
5. **支持国际化** - 多语言支持和本地化

记住，好的代码不仅要能工作，还要易读、易维护、易扩展。这份指南就是为了帮助你达到这个目标！

开始编写你的下一个思源笔记插件吧！🚀